---
title: "Next.js Performance Optimization Techniques"
date: "2024-03-10"
summary: "Explore advanced techniques for optimizing Next.js applications. From image optimization to code splitting, learn how to achieve Lighthouse scores above 90 and improve Core Web Vitals."
tags: ["Next.js", "Performance", "Optimization", "Web Vitals"]
cover: "/images/blog/nextjs-performance.jpg"
---

# Next.js Performance Optimization Techniques

Performance is crucial for user experience and SEO. In this guide, I'll share proven techniques to optimize your Next.js applications and achieve excellent Core Web Vitals scores.

## Why Performance Matters

- **User Experience**: Faster sites keep users engaged
- **SEO**: Google considers performance in rankings
- **Conversion**: Better performance leads to higher conversions
- **Accessibility**: Faster sites work better on slower connections

## Core Web Vitals

Google's Core Web Vitals are key metrics for performance:

- **Largest Contentful Paint (LCP)**: < 2.5s
- **First Input Delay (FID)**: < 100ms
- **Cumulative Layout Shift (CLS)**: < 0.1

## Image Optimization

Next.js Image component provides automatic optimization:

```typescript
import Image from 'next/image';

export function OptimizedImage() {
  return (
    <Image
      src="/hero-image.jpg"
      alt="Hero image"
      width={1200}
      height={600}
      priority // For above-the-fold images
      placeholder="blur"
      blurDataURL="data:image/jpeg;base64,..."
    />
  );
}
```

### Best Practices for Images

1. **Use WebP format** when possible
2. **Implement lazy loading** for below-the-fold images
3. **Provide proper dimensions** to prevent layout shift
4. **Use responsive images** for different screen sizes

## Code Splitting

Next.js automatically splits your code, but you can optimize further:

```typescript
import dynamic from 'next/dynamic';

// Lazy load components
const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <div>Loading...</div>,
  ssr: false // If component doesn't need SSR
});

// Lazy load libraries
const Chart = dynamic(() => import('react-chartjs-2'), {
  ssr: false
});
```

## Bundle Analysis

Use `@next/bundle-analyzer` to identify large dependencies:

```bash
npm install --save-dev @next/bundle-analyzer
```

```javascript
// next.config.js
const withBundleAnalyzer = require('@next/bundle-analyzer')({
  enabled: process.env.ANALYZE === 'true',
});

module.exports = withBundleAnalyzer({
  // your existing config
});
```

## Caching Strategies

### Static Generation with ISR

```typescript
export async function getStaticProps() {
  const data = await fetchData();
  
  return {
    props: { data },
    revalidate: 3600, // Revalidate every hour
  };
}
```

### API Route Caching

```typescript
// pages/api/data.ts
import { NextApiRequest, NextApiResponse } from 'next';

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  res.setHeader('Cache-Control', 's-maxage=3600, stale-while-revalidate');
  
  const data = await fetchData();
  res.json(data);
}
```

## Font Optimization

Optimize web fonts to prevent layout shift:

```typescript
import { Inter } from 'next/font/google';

const inter = Inter({
  subsets: ['latin'],
  display: 'swap', // Prevents layout shift
  preload: true,
});

export default function Layout({ children }) {
  return (
    <html lang="en" className={inter.className}>
      <body>{children}</body>
    </html>
  );
}
```

## Database and API Optimization

### Connection Pooling

```typescript
import { Pool } from 'pg';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  max: 20, // Maximum connections
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
});
```

### Query Optimization

```typescript
// Use indexes and limit results
const posts = await pool.query(
  'SELECT * FROM posts WHERE published = true ORDER BY created_at DESC LIMIT 10'
);
```

## Monitoring Performance

### Lighthouse CI

```yaml
# .github/workflows/lighthouse.yml
name: Lighthouse CI
on: [push]
jobs:
  lhci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Run Lighthouse CI
        run: |
          npm install -g @lhci/cli@0.12.x
          lhci autorun
```

### Real User Monitoring

```typescript
// Track Core Web Vitals
export function reportWebVitals(metric) {
  if (metric.label === 'web-vital') {
    console.log(metric);
    // Send to analytics service
  }
}
```

## Advanced Techniques

### Edge Runtime

```typescript
export const runtime = 'edge';

export async function GET() {
  return new Response('Hello from Edge Runtime');
}
```

### Streaming SSR

```typescript
import { Suspense } from 'react';

export default function Page() {
  return (
    <div>
      <h1>My Page</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <SlowComponent />
      </Suspense>
    </div>
  );
}
```

## Performance Checklist

- [ ] Optimize images with Next.js Image component
- [ ] Implement proper caching strategies
- [ ] Use code splitting for large components
- [ ] Optimize fonts with display: swap
- [ ] Monitor Core Web Vitals
- [ ] Use bundle analyzer to identify large dependencies
- [ ] Implement proper error boundaries
- [ ] Use Edge Runtime for faster responses
- [ ] Optimize database queries
- [ ] Implement proper loading states

## Conclusion

Performance optimization is an ongoing process. Start with the basics like image optimization and code splitting, then move to more advanced techniques. Always measure the impact of your optimizations using tools like Lighthouse and Core Web Vitals.

Remember: The goal is not just to achieve good scores, but to provide a better user experience for your visitors. 